[
  {
    "__docId__": 1,
    "kind": "external",
    "name": "Infinity",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Infinity",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Infinity",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 2,
    "kind": "external",
    "name": "NaN",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/NaN",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~NaN",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 3,
    "kind": "external",
    "name": "undefined",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/undefined",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~undefined",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 4,
    "kind": "external",
    "name": "null",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/null",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~null",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 5,
    "kind": "external",
    "name": "Object",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Object",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 6,
    "kind": "external",
    "name": "object",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~object",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 7,
    "kind": "external",
    "name": "Function",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Function",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 8,
    "kind": "external",
    "name": "function",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~function",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 9,
    "kind": "external",
    "name": "Boolean",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Boolean",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Boolean",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 10,
    "kind": "external",
    "name": "boolean",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Boolean",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~boolean",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 11,
    "kind": "external",
    "name": "Symbol",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Symbol",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 12,
    "kind": "external",
    "name": "Error",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Error",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 13,
    "kind": "external",
    "name": "EvalError",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/EvalError",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~EvalError",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 14,
    "kind": "external",
    "name": "InternalError",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/InternalError",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~InternalError",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 15,
    "kind": "external",
    "name": "RangeError",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RangeError",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~RangeError",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 16,
    "kind": "external",
    "name": "ReferenceError",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ReferenceError",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~ReferenceError",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 17,
    "kind": "external",
    "name": "SyntaxError",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/SyntaxError",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~SyntaxError",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 18,
    "kind": "external",
    "name": "TypeError",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypeError",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~TypeError",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 19,
    "kind": "external",
    "name": "URIError",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/URIError",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~URIError",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 20,
    "kind": "external",
    "name": "Number",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Number",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 21,
    "kind": "external",
    "name": "number",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~number",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 22,
    "kind": "external",
    "name": "Date",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Date",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 23,
    "kind": "external",
    "name": "String",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~String",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 24,
    "kind": "external",
    "name": "string",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~string",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 25,
    "kind": "external",
    "name": "RegExp",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~RegExp",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 26,
    "kind": "external",
    "name": "Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Array",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 27,
    "kind": "external",
    "name": "Int8Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Int8Array",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Int8Array",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 28,
    "kind": "external",
    "name": "Uint8Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint8Array",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Uint8Array",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 29,
    "kind": "external",
    "name": "Uint8ClampedArray",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint8ClampedArray",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Uint8ClampedArray",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 30,
    "kind": "external",
    "name": "Int16Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Int16Array",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Int16Array",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 31,
    "kind": "external",
    "name": "Uint16Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint16Array",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Uint16Array",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 32,
    "kind": "external",
    "name": "Int32Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Int32Array",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Int32Array",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 33,
    "kind": "external",
    "name": "Uint32Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint32Array",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Uint32Array",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 34,
    "kind": "external",
    "name": "Float32Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Float32Array",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Float32Array",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 35,
    "kind": "external",
    "name": "Float64Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Float64Array",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Float64Array",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 36,
    "kind": "external",
    "name": "Map",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Map",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 37,
    "kind": "external",
    "name": "Set",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Set",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 38,
    "kind": "external",
    "name": "WeakMap",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/WeakMap",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~WeakMap",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 39,
    "kind": "external",
    "name": "WeakSet",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/WeakSet",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~WeakSet",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 40,
    "kind": "external",
    "name": "ArrayBuffer",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~ArrayBuffer",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 41,
    "kind": "external",
    "name": "DataView",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DataView",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~DataView",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 42,
    "kind": "external",
    "name": "JSON",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~JSON",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 43,
    "kind": "external",
    "name": "Promise",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Promise",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 44,
    "kind": "external",
    "name": "Generator",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Generator",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Generator",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 45,
    "kind": "external",
    "name": "GeneratorFunction",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/GeneratorFunction",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~GeneratorFunction",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 46,
    "kind": "external",
    "name": "Reflect",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Reflect",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Reflect",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 47,
    "kind": "external",
    "name": "Proxy",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Proxy",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 48,
    "kind": "file",
    "name": "src/Collection.js",
    "content": "/**\n * class Collection\n */\n\n/**\n * Interact with a colection of records\n *\n * Do not instantiate this class directly, use methods from class {Store}\n *\n * @access public\n */\nmodule.exports = class Collection {\n\t/**\n\t * Get collection interaction instance\n\t *\n\t * @access public\n\t * @param {Store} store - object\n\t * @param {string} collection - collection name\n\t */\n\tconstructor(store, collection) {\n\t\t/**\n\t\t * @access private\n\t\t */\n\t\tthis._store = store;\n\t\t/**\n\t\t * @access private\n\t\t */\n\t\tthis._name = collection;\n\t}\n\n\n\t// Utility methods\n\n\t/**\n\t * Store instance for this collection\n\t *\n\t * @type Store\n\t */\n\tget store() {\n\t\treturn this._store;\n\t}\n\n\t/**\n\t * Collection name\n\t *\n\t * @type string\n\t */\n\tget name() {\n\t\treturn this._name;\n\t}\n\n\t/**\n\t * Get directory path within collection\n\t *\n\t * Directory is created if it doesn't exist.\n\t *\n\t * @param {array} dirParts - dir path components\n\t * @param {bool} create - true to create directory if it does not exist\n\t * @returns {Promise<string>} dirpath\n\t */\n\tasync dir(dirParts = [], create = true) {\n\t\treturn this.store.dir([this.store.option('recordsDir'), this.name, ...dirParts], create);\n\t}\n\n\n\t// Factory methods\n\n\t/**\n\t * Return an object to interact with a record within this collection\n\t *\n\t * @param {string} identifier - record identifier\n\t * @returns {Record} object\n\t */\n\trecord(identifier) {\n\t\treturn new (this.store.option('recordClass'))(this.store, this, identifier);\n\t}\n\n\n\t// Data operation methods\n\n\t/**\n\t * Iterate over all records in collection, calling function for each\n\t *\n\t * @param {function} callback - called for each record found\n\t *   Signature: `function(identiier, recordIndex, collectionObj): {(void|bool}}`\n\t *   If callback returns bool false, traversal is halted\n\t * @returns {Promise<number>} total records traversed\n\t */\n\tasync traverse(callback) {\n\t\tconst\n\t\t\trootDir = await this.dir([], false),\n\t\t\tpath = this.store.path,\n\t\t\tfs  = this.store.fs\n\t\t;\n\t\tfunction getDirectoriesInDir(dir) {\n\t\t\treturn new Promise((resolve, reject) => {\n\t\t\t\tfs.readdir(\n\t\t\t\t\tdir,\n\t\t\t\t\t{\n\t\t\t\t\t\twithFileTypes: true\n\t\t\t\t\t},\n\t\t\t\t\t(err, entries) => {\n\t\t\t\t\t\tif (err) {\n\t\t\t\t\t\t\tif (err.code == 'ENOENT') {\n\t\t\t\t\t\t\t\tresolve([]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treject(err);\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tlet dirs = [];\n\t\t\t\t\t\tfor (let ent of entries) {\n\t\t\t\t\t\t\tif (ent.isDirectory()) {\n\t\t\t\t\t\t\t\tdirs.push(ent.name);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tresolve(dirs);\n\t\t\t\t\t}\n\t\t\t\t);\n\t\t\t});\n\t\t}\n\t\tlet stack = [\n\t\t\t[rootDir, await getDirectoriesInDir(rootDir)]\n\t\t];\n\t\tlet recordCount = 0;\n\t\twhile (stack.length) {\n\t\t\tlet level = stack.length - 1;\n\t\t\tif (!stack[level][1].length) {\n\t\t\t\tstack.pop();\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tlet dir = path.join(stack[level][0], stack[level][1].pop());\n\t\t\tlet subdirs = await getDirectoriesInDir(dir);\n\t\t\tif (!subdirs.length) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (level < 3) {\n\t\t\t\tstack.push([dir, subdirs]);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfor (let identifier of subdirs) {\n\t\t\t\tif (callback(identifier, recordCount++, this) === false) {\n\t\t\t\t\tstack = [];\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn recordCount;\n\t}\n};\n",
    "static": true,
    "longname": "/Users/ky/Documents/local/morvren-achronos/code/fs-atomic-data-store/src/Collection.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 49,
    "kind": "class",
    "name": "Collection",
    "memberof": "src/Collection.js",
    "static": true,
    "longname": "src/Collection.js~Collection",
    "access": "public",
    "export": true,
    "importPath": "fs-atomic-data-store/src/Collection.js",
    "importStyle": "Collection",
    "description": "Interact with a colection of records\n\nDo not instantiate this class directly, use methods from class {Store}",
    "lineNumber": 12,
    "interface": false
  },
  {
    "__docId__": 50,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/Collection.js~Collection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Collection.js~Collection#constructor",
    "access": "public",
    "description": "Get collection interaction instance",
    "lineNumber": 20,
    "params": [
      {
        "nullable": null,
        "types": [
          "Store"
        ],
        "spread": false,
        "optional": false,
        "name": "store",
        "description": "object"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "collection",
        "description": "collection name"
      }
    ]
  },
  {
    "__docId__": 51,
    "kind": "member",
    "name": "_store",
    "memberof": "src/Collection.js~Collection",
    "static": false,
    "longname": "src/Collection.js~Collection#_store",
    "access": "private",
    "description": "",
    "lineNumber": 24,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 52,
    "kind": "member",
    "name": "_name",
    "memberof": "src/Collection.js~Collection",
    "static": false,
    "longname": "src/Collection.js~Collection#_name",
    "access": "private",
    "description": "",
    "lineNumber": 28,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 53,
    "kind": "get",
    "name": "store",
    "memberof": "src/Collection.js~Collection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Collection.js~Collection#store",
    "access": "public",
    "description": "Store instance for this collection",
    "lineNumber": 39,
    "type": {
      "nullable": null,
      "types": [
        "*"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 54,
    "kind": "get",
    "name": "name",
    "memberof": "src/Collection.js~Collection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Collection.js~Collection#name",
    "access": "public",
    "description": "Collection name",
    "lineNumber": 48,
    "type": {
      "nullable": null,
      "types": [
        "*"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 55,
    "kind": "method",
    "name": "dir",
    "memberof": "src/Collection.js~Collection",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "src/Collection.js~Collection#dir",
    "access": "public",
    "description": "Get directory path within collection\n\nDirectory is created if it doesn't exist.",
    "lineNumber": 61,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise<string>} dirpath"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "array"
        ],
        "spread": false,
        "optional": false,
        "name": "dirParts",
        "description": "dir path components"
      },
      {
        "nullable": null,
        "types": [
          "bool"
        ],
        "spread": false,
        "optional": false,
        "name": "create",
        "description": "true to create directory if it does not exist"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise<string>"
      ],
      "spread": false,
      "description": "dirpath"
    }
  },
  {
    "__docId__": 56,
    "kind": "method",
    "name": "record",
    "memberof": "src/Collection.js~Collection",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Collection.js~Collection#record",
    "access": "public",
    "description": "Return an object to interact with a record within this collection",
    "lineNumber": 74,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Record} object"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "identifier",
        "description": "record identifier"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Record"
      ],
      "spread": false,
      "description": "object"
    }
  },
  {
    "__docId__": 57,
    "kind": "method",
    "name": "traverse",
    "memberof": "src/Collection.js~Collection",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "src/Collection.js~Collection#traverse",
    "access": "public",
    "description": "Iterate over all records in collection, calling function for each",
    "lineNumber": 89,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise<number>} total records traversed"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "function"
        ],
        "spread": false,
        "optional": false,
        "name": "callback",
        "description": "called for each record found\n  Signature: `function(identiier, recordIndex, collectionObj): {(void|bool}}`\n  If callback returns bool false, traversal is halted"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise<number>"
      ],
      "spread": false,
      "description": "total records traversed"
    }
  },
  {
    "__docId__": 58,
    "kind": "file",
    "name": "src/Lock.js",
    "content": "/**\n * class Lock\n */\n\n/**\n * @typedef {Array<{collection: ?string, identifier: ?string, type: \"record\"|\"collection\"|\"store\", ours: ?bool}>} LockInfo\n */\n\n// Libraries\nconst lockfile = require('proper-lockfile');\n\n// Constants\n/**\n * @access private\n */\nconst\n\tSTORE_FILENAME = '@@--store@@',\n\tCOLLECTION_FILENAME = '@@--collection@@%s',\n\tCOLLECTION_FILENAME_REGEXP = new RegExp('^' + COLLECTION_FILENAME.replace(/%s/, '(.+)') + '$'),\n\tRECORD_FILENAME = '%s@@--record@@%s',\n\tRECORD_FILENAME_REGEXP = new RegExp('^' + RECORD_FILENAME.replace(/%s/g, '(.+)') + '$')\n;\n\n/**\n * Lock resources for exclusive access\n *\n * Do not instantiate this class directly, use methods from class {Store}\n */\nmodule.exports = class Lock {\n\t/**\n\t * Get locking instance\n\t *\n\t * @param {Store} store - object\n\t * @param {object} options\n\t * @param {number} options.timeout - default max retry time in milliseconds\n\t * @param {number} options.wait - default min time in ms to wait before first retry\n\t */\n\tconstructor(store, options) {\n\t\t/**\n\t\t * @access private\n\t\t */\n\t\tthis._store = store;\n\t\t/**\n\t\t * @access private\n\t\t */\n\t\tthis._options = {\n\t\t\ttimeout: options.timeout || 0,\n\t\t\twait: options.wait || 10\n\t\t};\n\t\t/**\n\t\t * @access private\n\t\t */\n\t\tthis._locks = {};\n\t}\n\n\n\t// Utility methods\n\n\t/**\n\t * Store instance for this collection\n\t *\n\t * @type Store\n\t */\n\tget store() {\n\t\treturn this._store;\n\t}\n\n\t/**\n\t * Utility. Get filename for a lock\n\t *\n\t * For a record lock, pass string collection and identifier.\n\t * For a collection-level lock, pass string collection and null for identifier.\n\t * For a store-level lock, pass null for both parameters\n\t *\n\t * @param {?string} collection - collection name\n\t * @param {?string} identifier - identifier name\n\t * @returns {string} filename\n\t */\n\tfilename(collection, identifier) {\n\t\tif (collection == null && identifier == null) {\n\t\t\treturn STORE_FILENAME;\n\t\t}\n\t\tif (identifier == null) {\n\t\t\treturn COLLECTION_FILENAME.replace(/%s/, collection);\n\t\t}\n\t\treturn RECORD_FILENAME.replace(/%s/, collection).replace(/%s/, identifier);\n\t}\n\n\t/**\n\t * Utility. Get lock info from lock filename\n\t *\n\t * @param {string} filename - lock filename\n\t * @return {LockInfo} lock info\n\t */\n\tparseFilename(filename) {\n\t\tif (filename == STORE_FILENAME) {\n\t\t\treturn {\n\t\t\t\tcollection: null,\n\t\t\t\tidentifier: null,\n\t\t\t\ttype: 'store',\n\t\t\t\tours: null\n\t\t\t}\n\t\t}\n\t\tlet m;\n\t\tif ((m = COLLECTION_FILENAME_REGEXP.exec(filename))) {\n\t\t\treturn {\n\t\t\t\tcollection: m[1],\n\t\t\t\tidentifier: null,\n\t\t\t\ttype: 'collection',\n\t\t\t\tours: null\n\t\t\t}\n\t\t}\n\t\tif ((m = RECORD_FILENAME_REGEXP.exec(filename))) {\n\t\t\treturn {\n\t\t\t\tcollection: m[1],\n\t\t\t\tidentifier: m[2],\n\t\t\t\ttype: 'record',\n\t\t\t\tours: null\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n\t/**\n\t * Utility. Return array of retry delay times\n\t *\n\t * @param {number} timeout - maximum retry delay time in milliseconds\n\t * @param {number} wait - minimum delay before first retry, in milliseconds\n\t * @returns {array} retry timer values, can be passed to setTimeout\n\t */\n\tcalcRetries(timeout, wait) {\n\t\tlet retries = [];\n\t\tif (timeout > 0) {\n\t\t\twhile (timeout >= wait) {\n\t\t\t\tretries.unshift(timeout);\n\t\t\t\ttimeout = Math.floor(timeout / 3);\n\t\t\t}\n\t\t\tfor (let i = 1; i < retries.length; i++) {\n\t\t\t\tretries[i] -= retries[i - 1];\n\t\t\t}\n\t\t}\n\t\treturn retries;\n\t}\n\n\t/**\n\t * Utility. Perform an operation and retry it if first attempt(s) fail\n\t *\n\t * @param {function} operation - Signature: `function(resolve, reject, retry, tryCount): Promise<void>`\n\t * @param {function} onTimeout - On timeout, operation promise is rejected with value returned by this function\n\t * @param {object} options\n\t * @param {number} options.timeout - max retry time in milliseconds, default is as provided to Lock constructor\n\t * @param {number} options.wait - min time to wait before first retry, default is as provided to Lock constructor\n\t */\n\tasync runWithRetry(operation, onTimeout, options = {}) {\n\t\toptions.timeout = options.timeout || this._options.timeout;\n\t\toptions.wait = options.wait || this._options.wait;\n\t\treturn new Promise((resolve, reject) => {\n\t\t\tlet retries = this.calcRetries(options.timeout, options.wait);\n\t\t\tlet tryCount = 0;\n\t\t\tfunction retry() {\n\t\t\t\tif (retries.length == 0) {\n\t\t\t\t\treject(onTimeout());\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tsetTimeout(run, retries.shift());\n\t\t\t}\n\t\t\tfunction run() {\n\t\t\t\toperation(resolve, reject, retry, tryCount++);\n\t\t\t}\n\t\t\trun();\n\t\t});\n\t}\n\n\t/**\n\t * Utility. Get directory path for locks\n\t *\n\t * Directory is created if it doesn't exist.\n\t *\n\t * @param {bool} create - true to create directory if it does not exist\n\t * @returns {Promise<string>} dirpath\n\t */\n\tasync dir(create = true) {\n\t\treturn this.store.dir([this.store.option('locksDir')], create);\n\t}\n\n\n\t// Data operation methods\n\n\t/**\n\t * Attempt to take an exclusive lock\n\t *\n\t * If the lock is free, it will be taken by this instance.\n\t * If the lock is already held by this instance, calling {lock} again will resolve ok.\n\t * If the lock is held by another instance or process, rejects with code \"ELOCKED\" and lockType \"record\".\n\t * If the collection is locked (by this or any other instance), rejects with code \"ELOCKED\" and lockType \"collection\".\n\t * If the store is locked (by this or any other instance), rejects with code \"ELOCKED\" and lockType \"store\".\n\t *\n\t * @param {?string} collection - collection name, or null for store-level lock\n\t * @param {?string} identifier - record identifier, or null for collection-level lock\n\t * @param {object} options\n\t * @param {number} options.timeout - max retry time in milliseconds. Default is per options to constructor\n\t * @param {number} options.wait - min time in ms to wait before first retry. Default is per options to constructor\n\t * @returns {Promise<void>}\n\t */\n\tasync lock(collection, identifier, options = {}) {\n\t\tconst\n\t\t\tdir = await this.dir(),\n\t\t\tpath = this.store.path,\n\t\t\tfilename = this.filename(collection, identifier),\n\t\t\tfilepath = path.join(dir, filename)\n\t\t;\n\n\t\t// Check whether this instance already holds lock\n\t\tif (this._locks[filename]) {\n\t\t\t// Confirm we really still have it\n\t\t\tif (await this._lockOperation('check', filepath)) {\n\t\t\t\t// We do\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t// We don't... this is bad but nothing we can do about it here, unlock will throw\n\t\t}\n\n\t\t// Check for store-level lock\n\t\tif (await this._lockOperation('check', path.join(dir, this.filename(null, null)))) {\n\t\t\t// Store is locked\n\t\t\tconst err = new Error('Error: ELOCKED: store is locked');\n\t\t\terr.code = 'ELOCKED';\n\t\t\terr.lockType = 'store';\n\t\t\tthrow err;\n\t\t}\n\n\t\t// Check for collection lock\n\t\tif (collection && await this._lockOperation('check', path.join(dir, this.filename(collection, null)))) {\n\t\t\t// Store is locked\n\t\t\tconst err = new Error('Error: ELOCKED: collection is locked');\n\t\t\terr.code = 'ELOCKED';\n\t\t\terr.lockType = 'collection';\n\t\t\tthrow err;\n\t\t}\n\n\t\t// Attempt to take lock\n\t\treturn this.runWithRetry(\n\t\t\t(resolve, reject, retry) => {\n\t\t\t\tthis._lockOperation('lock', filepath)\n\t\t\t\t\t.then((release) => {\n\t\t\t\t\t\tthis._locks[filename] = {\n\t\t\t\t\t\t\tc: collection,\n\t\t\t\t\t\t\ti: identifier,\n\t\t\t\t\t\t\tr: release\n\t\t\t\t\t\t};\n\t\t\t\t\t\tresolve();\n\t\t\t\t\t})\n\t\t\t\t\t.catch((err) => {\n\t\t\t\t\t\tif (err.code != 'ELOCKED') {\n\t\t\t\t\t\t\treject(err);\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tretry();\n\t\t\t\t\t})\n\t\t\t\t;\n\t\t\t},\n\t\t\t() => {\n\t\t\t\tconst err = new Error('Error: ELOCKED: lock is held by another instance');\n\t\t\t\terr.code = 'ELOCKED';\n\t\t\t\terr.lockType = 'lock';\n\t\t\t\treturn err;\n\t\t\t},\n\t\t\toptions\n\t\t);\n\t}\n\n\t/**\n\t * Release a lock held by this instance\n\t *\n\t * If lock is not held by this instance, rejects with code \"ENOTACQUIRED\".\n\t * If lock has been compromised, rejects with code \"ECOMPROMISED\".\n\t *\n\t * @param {?string} collection - collection name, or null for store-level lock\n\t * @param {?string} identifier - record identifier, or null for collection-level lock\n\t * @returns {Promise<void>}\n\t */\n\tasync unlock(collection, identifier) {\n\t\tconst\n\t\t\tpath = this.store.path,\n\t\t\tfilename = this.filename(collection, identifier)\n\t\t;\n\n\t\t// Check whether this instance holds lock\n\t\tif (!this._locks[filename]) {\n\t\t\tlet err = new Error('Error: ENOTACQUIRED: lock is not held by this instance');\n\t\t\terr.code = 'ENOTACQUIRED';\n\t\t\tthrow err;\n\t\t}\n\n\t\t// Confirm we really still have it\n\t\tlet err;\n\t\tif (await this._lockOperation('check', path.join(await this.dir(), filename)) == false) {\n\t\t\t// We don't... throw error\n\t\t\terr = new Error('Error: ECOMPROMISED: lock has been removed by another process, possible simultaneous data access');\n\t\t\terr.code = 'ECOMPROMISED';\n\t\t}\n\n\t\t// Release lock\n\t\tawait this._locks[filename].r();\n\t\tdelete this._locks[filename];\n\n\t\t// Throw error if present\n\t\tif (err) {\n\t\t\tthrow err;\n\t\t}\n\t}\n\n\t/**\n\t * Release all locks held by this instance\n\t *\n\t * @returns {Promise<void>}\n\t */\n\tasync unlockAll() {\n\t\tfor (let k of Object.keys(this._locks)) {\n\t\t\t// Release lock\n\t\t\tawait this._locks[k].r();\n\t\t\tdelete this._locks[k];\n\t\t}\n\t}\n\n\t/**\n\t * List locks currently held by this instance\n\t *\n\t * @return LockInfo[] held locks\n\t */\n\tlist() {\n\t\tlet locks = [];\n\t\tfor (let k in this._locks) {\n\t\t\tlocks.push({\n\t\t\t\tcollection: this._locks[k].c,\n\t\t\t\tidentifier: this._locks[k].i,\n\t\t\t\ttype:\n\t\t\t\t\t(this._locks[k].c == null)\n\t\t\t\t\t? 'store'\n\t\t\t\t\t: (\n\t\t\t\t\t\t(this._locks[k].i == null)\n\t\t\t\t\t\t? 'collection'\n\t\t\t\t\t\t: 'record'\n\t\t\t\t\t),\n\t\t\t\tours: true\n\t\t\t});\n\t\t}\n\t\tthis._sortLockList(locks);\n\t\treturn locks;\n\t}\n\n\t/**\n\t * List locks currently held by all actors (all processes, all instances)\n\t *\n\t * @return {LockInfo[]} held locks\n\t */\n\tasync listGlobal() {\n\t\tconst\n\t\t\tdir = await this.dir(),\n\t\t\tfs = this.store.fs\n\t\t;\n\t\treturn new Promise((resolve, reject) => {\n\t\t\tfs.readdir(\n\t\t\t\tdir,\n\t\t\t\t{\n\t\t\t\t\twithFileTypes: true\n\t\t\t\t},\n\t\t\t\t(err, entries) => {\n\t\t\t\t\tif (err) {\n\t\t\t\t\t\treject(err);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tlet locks = [];\n\t\t\t\t\tfor (let ent of entries) {\n\t\t\t\t\t\tif (ent.isDirectory()) {\n\t\t\t\t\t\t\tlet lockinfo = this.parseFilename(ent.name)\n\t\t\t\t\t\t\tlockinfo.ours = (typeof this._locks[ent.name] == 'object');\n\t\t\t\t\t\t\tlocks.push(lockinfo);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tthis._sortLockList(locks);\n\t\t\t\t\tresolve(locks);\n\t\t\t\t}\n\t\t\t);\n\t\t});\n\t}\n\n\n\t// Convenience methods\n\n\t/**\n\t * Attempt to take a collection-level lock (lock an entire collection)\n\t *\n\t * @param {string} collection - collection name\n\t * @returns {Promise<void>}\n\t */\n\tasync lockCollection(collection) {\n\t\treturn this.lock(collection, null);\n\t}\n\n\t/**\n\t * Attempt to take a store-level lock (lock the entire store)\n\t *\n\t * @returns {Promise<void>}\n\t */\n\tasync lockStore() {\n\t\treturn this.lock(null, null);\n\t}\n\n\t/**\n\t * Release a held colection-level lock\n\t *\n\t * @param {string} collection - collection name\n\t * @returns {Promise<void>}\n\t */\n\tasync unlockCollection(collection) {\n\t\treturn this.unlock(collection, null);\n\t}\n\n\t/**\n\t * Release held store-level lock\n\t */\n\tasync unlockStore() {\n\t\treturn this.unlock(null, null);\n\t}\n\n\n\t// Internal methods\n\n\t/**\n\t * @access private\n\t */\n\t_lockOperation(method, filepath) {\n\t\treturn lockfile[method](\n\t\t\tfilepath,\n\t\t\t{\n\t\t\t\trealpath: false,\n\t\t\t\tlockfilePath: filepath\n\t\t\t}\n\t\t);\n\t}\n\n\t/**\n\t * @access private\n\t */\n\t_sortLockList(locks) {\n\t\tconst typeSortMap = {\n\t\t\tstore: 0,\n\t\t\tcollection: 1,\n\t\t\trecord: 2\n\t\t};\n\t\tlocks.sort((a, b) => {\n\t\t\tlet v = typeSortMap[a.type] - typeSortMap[b.type];\n\t\t\tif (v) {\n\t\t\t\treturn v;\n\t\t\t}\n\t\t\tv = a.collection.localeCompare(b.collection);\n\t\t\tif (v) {\n\t\t\t\treturn v;\n\t\t\t}\n\t\t\treturn a.identifier.localeCompare(b.identifier);\n\t\t});\n\t}\n};\n",
    "static": true,
    "longname": "/Users/ky/Documents/local/morvren-achronos/code/fs-atomic-data-store/src/Lock.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 59,
    "kind": "typedef",
    "name": "LockInfo",
    "memberof": "src/Lock.js",
    "static": true,
    "longname": "src/Lock.js~LockInfo",
    "access": "public",
    "description": "",
    "lineNumber": 10,
    "type": {
      "types": [
        "Array<{collection: ?string, identifier: ?string, type: \"record\"|\"collection\"|\"store\", ours: ?bool}>"
      ],
      "optional": false,
      "name": "LockInfo"
    }
  },
  {
    "__docId__": 60,
    "kind": "variable",
    "name": "STORE_FILENAME",
    "memberof": "src/Lock.js",
    "static": true,
    "longname": "src/Lock.js~STORE_FILENAME",
    "access": "private",
    "export": false,
    "importPath": "fs-atomic-data-store/src/Lock.js",
    "importStyle": null,
    "description": "",
    "lineNumber": 16,
    "type": {
      "types": [
        "string"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 61,
    "kind": "class",
    "name": "Lock",
    "memberof": "src/Lock.js",
    "static": true,
    "longname": "src/Lock.js~Lock",
    "access": "public",
    "export": true,
    "importPath": "fs-atomic-data-store/src/Lock.js",
    "importStyle": "Lock",
    "description": "Lock resources for exclusive access\n\nDo not instantiate this class directly, use methods from class {Store}",
    "lineNumber": 29,
    "interface": false
  },
  {
    "__docId__": 62,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/Lock.js~Lock",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Lock.js~Lock#constructor",
    "access": "public",
    "description": "Get locking instance",
    "lineNumber": 38,
    "params": [
      {
        "nullable": null,
        "types": [
          "Store"
        ],
        "spread": false,
        "optional": false,
        "name": "store",
        "description": "object"
      },
      {
        "nullable": null,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": false,
        "name": "options",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "options.timeout",
        "description": "default max retry time in milliseconds"
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "options.wait",
        "description": "default min time in ms to wait before first retry"
      }
    ]
  },
  {
    "__docId__": 63,
    "kind": "member",
    "name": "_store",
    "memberof": "src/Lock.js~Lock",
    "static": false,
    "longname": "src/Lock.js~Lock#_store",
    "access": "private",
    "description": "",
    "lineNumber": 42,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 64,
    "kind": "member",
    "name": "_options",
    "memberof": "src/Lock.js~Lock",
    "static": false,
    "longname": "src/Lock.js~Lock#_options",
    "access": "private",
    "description": "",
    "lineNumber": 46,
    "type": {
      "types": [
        "{\"timeout\": *, \"wait\": *}"
      ]
    }
  },
  {
    "__docId__": 65,
    "kind": "member",
    "name": "_locks",
    "memberof": "src/Lock.js~Lock",
    "static": false,
    "longname": "src/Lock.js~Lock#_locks",
    "access": "private",
    "description": "",
    "lineNumber": 53,
    "type": {
      "types": [
        "{}"
      ]
    }
  },
  {
    "__docId__": 66,
    "kind": "get",
    "name": "store",
    "memberof": "src/Lock.js~Lock",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Lock.js~Lock#store",
    "access": "public",
    "description": "Store instance for this collection",
    "lineNumber": 64,
    "type": {
      "nullable": null,
      "types": [
        "*"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 67,
    "kind": "method",
    "name": "filename",
    "memberof": "src/Lock.js~Lock",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Lock.js~Lock#filename",
    "access": "public",
    "description": "Utility. Get filename for a lock\n\nFor a record lock, pass string collection and identifier.\nFor a collection-level lock, pass string collection and null for identifier.\nFor a store-level lock, pass null for both parameters",
    "lineNumber": 79,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{string} filename"
      }
    ],
    "params": [
      {
        "nullable": true,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "collection",
        "description": "collection name"
      },
      {
        "nullable": true,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "identifier",
        "description": "identifier name"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": "filename"
    }
  },
  {
    "__docId__": 68,
    "kind": "method",
    "name": "parseFilename",
    "memberof": "src/Lock.js~Lock",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Lock.js~Lock#parseFilename",
    "access": "public",
    "description": "Utility. Get lock info from lock filename",
    "lineNumber": 95,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "filename",
        "description": "lock filename"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "LockInfo"
      ],
      "spread": false,
      "description": "lock info"
    }
  },
  {
    "__docId__": 69,
    "kind": "method",
    "name": "calcRetries",
    "memberof": "src/Lock.js~Lock",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Lock.js~Lock#calcRetries",
    "access": "public",
    "description": "Utility. Return array of retry delay times",
    "lineNumber": 131,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{array} retry timer values, can be passed to setTimeout"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "timeout",
        "description": "maximum retry delay time in milliseconds"
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "wait",
        "description": "minimum delay before first retry, in milliseconds"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "array"
      ],
      "spread": false,
      "description": "retry timer values, can be passed to setTimeout"
    }
  },
  {
    "__docId__": 70,
    "kind": "method",
    "name": "runWithRetry",
    "memberof": "src/Lock.js~Lock",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "src/Lock.js~Lock#runWithRetry",
    "access": "public",
    "description": "Utility. Perform an operation and retry it if first attempt(s) fail",
    "lineNumber": 154,
    "params": [
      {
        "nullable": null,
        "types": [
          "function"
        ],
        "spread": false,
        "optional": false,
        "name": "operation",
        "description": "Signature: `function(resolve, reject, retry, tryCount): Promise<void>`"
      },
      {
        "nullable": null,
        "types": [
          "function"
        ],
        "spread": false,
        "optional": false,
        "name": "onTimeout",
        "description": "On timeout, operation promise is rejected with value returned by this function"
      },
      {
        "nullable": null,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": false,
        "name": "options",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "options.timeout",
        "description": "max retry time in milliseconds, default is as provided to Lock constructor"
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "options.wait",
        "description": "min time to wait before first retry, default is as provided to Lock constructor"
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 71,
    "kind": "method",
    "name": "dir",
    "memberof": "src/Lock.js~Lock",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "src/Lock.js~Lock#dir",
    "access": "public",
    "description": "Utility. Get directory path for locks\n\nDirectory is created if it doesn't exist.",
    "lineNumber": 182,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise<string>} dirpath"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "bool"
        ],
        "spread": false,
        "optional": false,
        "name": "create",
        "description": "true to create directory if it does not exist"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise<string>"
      ],
      "spread": false,
      "description": "dirpath"
    }
  },
  {
    "__docId__": 72,
    "kind": "method",
    "name": "lock",
    "memberof": "src/Lock.js~Lock",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "src/Lock.js~Lock#lock",
    "access": "public",
    "description": "Attempt to take an exclusive lock\n\nIf the lock is free, it will be taken by this instance.\nIf the lock is already held by this instance, calling {lock} again will resolve ok.\nIf the lock is held by another instance or process, rejects with code \"ELOCKED\" and lockType \"record\".\nIf the collection is locked (by this or any other instance), rejects with code \"ELOCKED\" and lockType \"collection\".\nIf the store is locked (by this or any other instance), rejects with code \"ELOCKED\" and lockType \"store\".",
    "lineNumber": 205,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise<void>}"
      }
    ],
    "params": [
      {
        "nullable": true,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "collection",
        "description": "collection name, or null for store-level lock"
      },
      {
        "nullable": true,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "identifier",
        "description": "record identifier, or null for collection-level lock"
      },
      {
        "nullable": null,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": false,
        "name": "options",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "options.timeout",
        "description": "max retry time in milliseconds. Default is per options to constructor"
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "options.wait",
        "description": "min time in ms to wait before first retry. Default is per options to constructor"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise<void>"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 73,
    "kind": "method",
    "name": "unlock",
    "memberof": "src/Lock.js~Lock",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "src/Lock.js~Lock#unlock",
    "access": "public",
    "description": "Release a lock held by this instance\n\nIf lock is not held by this instance, rejects with code \"ENOTACQUIRED\".\nIf lock has been compromised, rejects with code \"ECOMPROMISED\".",
    "lineNumber": 282,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise<void>}"
      }
    ],
    "params": [
      {
        "nullable": true,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "collection",
        "description": "collection name, or null for store-level lock"
      },
      {
        "nullable": true,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "identifier",
        "description": "record identifier, or null for collection-level lock"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise<void>"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 74,
    "kind": "method",
    "name": "unlockAll",
    "memberof": "src/Lock.js~Lock",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "src/Lock.js~Lock#unlockAll",
    "access": "public",
    "description": "Release all locks held by this instance",
    "lineNumber": 318,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise<void>}"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise<void>"
      ],
      "spread": false,
      "description": ""
    },
    "params": []
  },
  {
    "__docId__": 75,
    "kind": "method",
    "name": "list",
    "memberof": "src/Lock.js~Lock",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Lock.js~Lock#list",
    "access": "public",
    "description": "List locks currently held by this instance",
    "lineNumber": 331,
    "return": {
      "nullable": null,
      "types": [
        "*"
      ],
      "spread": false,
      "description": "LockInfo[] held locks"
    },
    "params": []
  },
  {
    "__docId__": 76,
    "kind": "method",
    "name": "listGlobal",
    "memberof": "src/Lock.js~Lock",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "src/Lock.js~Lock#listGlobal",
    "access": "public",
    "description": "List locks currently held by all actors (all processes, all instances)",
    "lineNumber": 357,
    "return": {
      "nullable": null,
      "types": [
        "LockInfo[]"
      ],
      "spread": false,
      "description": "held locks"
    },
    "params": []
  },
  {
    "__docId__": 77,
    "kind": "method",
    "name": "lockCollection",
    "memberof": "src/Lock.js~Lock",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "src/Lock.js~Lock#lockCollection",
    "access": "public",
    "description": "Attempt to take a collection-level lock (lock an entire collection)",
    "lineNumber": 397,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise<void>}"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "collection",
        "description": "collection name"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise<void>"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 78,
    "kind": "method",
    "name": "lockStore",
    "memberof": "src/Lock.js~Lock",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "src/Lock.js~Lock#lockStore",
    "access": "public",
    "description": "Attempt to take a store-level lock (lock the entire store)",
    "lineNumber": 406,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise<void>}"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise<void>"
      ],
      "spread": false,
      "description": ""
    },
    "params": []
  },
  {
    "__docId__": 79,
    "kind": "method",
    "name": "unlockCollection",
    "memberof": "src/Lock.js~Lock",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "src/Lock.js~Lock#unlockCollection",
    "access": "public",
    "description": "Release a held colection-level lock",
    "lineNumber": 416,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise<void>}"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "collection",
        "description": "collection name"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise<void>"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 80,
    "kind": "method",
    "name": "unlockStore",
    "memberof": "src/Lock.js~Lock",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "src/Lock.js~Lock#unlockStore",
    "access": "public",
    "description": "Release held store-level lock",
    "lineNumber": 423,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 81,
    "kind": "method",
    "name": "_lockOperation",
    "memberof": "src/Lock.js~Lock",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Lock.js~Lock#_lockOperation",
    "access": "private",
    "description": "",
    "lineNumber": 433,
    "params": [
      {
        "name": "method",
        "types": [
          "*"
        ]
      },
      {
        "name": "filepath",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 82,
    "kind": "method",
    "name": "_sortLockList",
    "memberof": "src/Lock.js~Lock",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Lock.js~Lock#_sortLockList",
    "access": "private",
    "description": "",
    "lineNumber": 446,
    "params": [
      {
        "name": "locks",
        "types": [
          "*"
        ]
      }
    ],
    "return": null
  },
  {
    "__docId__": 83,
    "kind": "file",
    "name": "src/Record.js",
    "content": "/**\n * class Record\n */\n\n // Libraries\n const stream = require('stream');\n\n/**\n * Interact with a record\n *\n * Do not instantiate this class directly, use methods from class {Store}\n */\nmodule.exports = class Record {\n\t/**\n\t * Get record interaction instance\n\t *\n\t * @param {Store} store - object\n\t * @param {Collection} collection - object\n\t * @param {string} identifier - record identifier\n\t */\n\tconstructor(store, collection, identifier) {\n\t\t/**\n\t\t * @access private\n\t\t */\n\t\tthis._store = store;\n\t\t/**\n\t\t * @access private\n\t\t */\n\t\tthis._col = collection;\n\t\t/**\n\t\t * @access private\n\t\t */\n\t\tthis._id = identifier;\n\t}\n\n\n\t// Utility methods\n\n\t/**\n\t * Store instance for this record\n\t *\n\t * @type {Store}\n\t */\n\tget store() {\n\t\treturn this._store;\n\t}\n\n\t/**\n\t * Collection instance for this record\n\t *\n\t * @type {Collection}\n\t */\n\tget collection() {\n\t\treturn this._col;\n\t}\n\n\t/**\n\t * Identifier for this record\n\t *\n\t * @type {string}\n\t */\n\tget identifier() {\n\t\treturn this._id;\n\t}\n\n\t/**\n\t * Return hex-encoded 32-bit unsigned integer hash of record identifier\n\t *\n\t * Based on npm module string-hash (https://github.com/darkskyapp/string-hash) by The Dark Sky Company, LLC\n\t * That code is licensed under CC0-1.0\n\t *\n\t * @return {string} 8-character hex encoding of hash\n\t */\n\tgenerateHash() {\n\t\tlet\n\t\t\thash = 5381,\n\t\t\tid = this.identifier,\n\t\t\ti = id.length\n\t\t;\n\t\twhile(i) {\n\t\t\thash = (hash * 33) ^ id.charCodeAt(--i);\n\t\t}\n\t\thash = (hash >>> 0).toString(16);\n\t\tif (hash.length < 8) {\n\t\t\thash = '0'.repeat(8 - hash.length) + hash;\n\t\t}\n\t\treturn hash;\n\t}\n\n\t/**\n\t * Get directory path of record\n\t *\n\t * Directory is created if it doesn't exist.\n\t *\n\t * @param {bool} create - true to create directory if it does not exist\n\t * @returns {Promise<string>} dirpath\n\t */\n\tasync dir(create = true) {\n\t\tlet\n\t\t\thash = this.generateHash(),\n\t\t\tdirParts = []\n\t\t;\n\t\tfor (let i = 0; i < 8; i += 2) {\n\t\t\tdirParts.push(hash.slice(i, i + 2));\n\t\t}\n\t\treturn this.collection.dir([...dirParts, this.identifier], create);\n\t}\n\n\t/**\n\t * Get file path of record part\n\t *\n\t * @param {?string} part - name of part, or null for default part\n\t * @param {bool} createDir - true to create directory if it does not exist\n\t * @returns {Promise<string>} filepath\n\t */\n\tasync filepath(part = null, createDir = true) {\n\t\treturn this.store.path.join(\n\t\t\tawait this.dir(createDir),\n\t\t\tpart || this.store.option('defaultPart')\n\t\t);\n\t}\n\n\n\t// Data operation methods\n\n\t/**\n\t * Get list of record parts\n\t *\n\t * @returns {Promise<array>} partnames\n\t */\n\tasync listParts() {\n\t\tconst\n\t\t\tdir = await this.dir(false),\n\t\t\tfs = this.store.fs\n\t\t;\n\t\treturn new Promise((resolve, reject) => {\n\t\t\tfs.readdir(\n\t\t\t\tdir,\n\t\t\t\t{\n\t\t\t\t\twithFileTypes: true\n\t\t\t\t},\n\t\t\t\t(err, entries) => {\n\t\t\t\t\tif (err) {\n\t\t\t\t\t\tif (err.code == 'ENOENT') {\n\t\t\t\t\t\t\tresolve([]);\n\t\t\t\t\t\t}\n\t\t\t\t\t\treject(err);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tlet files = [];\n\t\t\t\t\tfor (let ent of entries) {\n\t\t\t\t\t\tif (ent.isFile()) {\n\t\t\t\t\t\t\tfiles.push(ent.name);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tfiles.sort();\n\t\t\t\t\tresolve(files);\n\t\t\t\t}\n\t\t\t);\n\t\t});\n\t}\n\n\t/**\n\t * Get file stat data for multiple record parts\n\t *\n\t * @param {array} parts - part names to remove\n\t * @returns {Promise<object>} results. Property name is part name. Property value is {fs.Stats}\n\t */\n\tasync statMultipleParts(parts) {\n\t\tconst\n\t\t\tdir = await this.dir(false),\n\t\t\tpath = this.store.path,\n\t\t\tfs  = this.store.fs\n\t\t;\n\t\tif (!(parts instanceof Array)) {\n\t\t\tparts = Object.keys(parts);\n\t\t}\n\t\tlet promises = [];\n\t\tlet results = {};\n\t\tfor (let part of parts) {\n\t\t\tpromises.push(new Promise(async (resolve, reject) => {\n\t\t\t\tfs.stat(\n\t\t\t\t\tpath.join(dir, part),\n\t\t\t\t\t(err, stat) => {\n\t\t\t\t\t\tif (err) {\n\t\t\t\t\t\t\treject(err);\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tresults[part] = stat;\n\t\t\t\t\t\tresolve();\n\t\t\t\t\t}\n\t\t\t\t);\n\t\t\t}));\n\t\t}\n\t\tawait Promise.all(promises);\n\t\treturn results;\n\t}\n\n\t/**\n\t * Read multiple record parts\n\t *\n\t * @param {(array|object} parts - {array} of part names to read, each is returned in Buffer. Or, {object} of part names and handling instructions:\n\t * @param {bool false} parts.__partname__ - return content in Buffer\n\t * @param {bool true} parts.__partname__ - return ReadStream\n\t * @param {stream.Writable} parts.__partname__ - pipe part content to this stream\n\t * @returns {Promise<object>} results. Property name is part name. Property value is {Buffer} or {fs.ReadStream} or {bool true}\n\t */\n\tasync readMultipleParts(parts) {\n\t\tconst\n\t\t\tdir = await this.dir(false),\n\t\t\tpath = this.store.path,\n\t\t\tfs  = this.store.fs\n\t\t;\n\t\tif (Array.isArray(parts)) {\n\t\t\tlet p = {};\n\t\t\tfor (let part of parts) {\n\t\t\t\tp[part] = false;\n\t\t\t}\n\t\t\tparts = p;\n\t\t}\n\t\tlet promises = [];\n\t\tlet results = {};\n\t\tfor (let part in parts) {\n\t\t\tlet filepath = path.join(dir, part);\n\t\t\tif (parts[part] === true) {\n\t\t\t\tresults[part] = fs.createReadStream(filepath);\n\t\t\t}\n\t\t\telse if (parts[part] instanceof stream.Writable) {\n\t\t\t\tpromises.push(new Promise((resolve, reject) => {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tlet reader = fs.createReadStream(filepath);\n\t\t\t\t\t\treader.on('error', (err) => {\n\t\t\t\t\t\t\treject(err);\n\t\t\t\t\t\t});\n\t\t\t\t\t\t/* readers have 'end', writers have 'finish' */\n\t\t\t\t\t\treader.on('end', () => {\n\t\t\t\t\t\t\tresolve();\n\t\t\t\t\t\t});\n\t\t\t\t\t\treader.pipe(parts[part]);\n\t\t\t\t\t\tresults[part] = true;\n\t\t\t\t\t}\n\t\t\t\t\tcatch (err) {\n\t\t\t\t\t\treject(err);\n\t\t\t\t\t}\n\t\t\t\t}));\n\t\t\t}\n\t\t\telse {\n\t\t\t\tpromises.push(new Promise((resolve, reject) => {\n\t\t\t\t\tfs.readFile(\n\t\t\t\t\t\tfilepath,\n\t\t\t\t\t\t(err, content) => {\n\t\t\t\t\t\t\tif (err) {\n\t\t\t\t\t\t\t\treject(err);\n\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tresults[part] = content;\n\t\t\t\t\t\t\tresolve();\n\t\t\t\t\t\t}\n\t\t\t\t\t);\n\t\t\t\t}));\n\t\t\t}\n\t\t}\n\t\tawait Promise.all(promises);\n\t\treturn results;\n\t}\n\n\t/**\n\t * Write multiple record parts\n\t *\n\t * @param {object} parts - part names and contents to write. Each property is a part to write. Property name is part name. Property value specifies part contents\n\t * @param {(Buffer|string)} parts.__partname__ - contents to write\n\t * @param {stream.Readable} parts.__partname__ - pipe part contents from this stream\n\t * @param {bool true} parts.__partname__ - return {fs.WriteStream}\n\t * @returns {Promise<object>} results. Property name is part name. Property value is {bool true} or {fs.WriteStream}\n\t */\n\tasync writeMultipleParts(parts) {\n\t\tconst\n\t\t\tdir = await this.dir(),\n\t\t\tpath = this.store.path,\n\t\t\tfs  = this.store.fs,\n\t\t\tfileMode = this.store.option('fileMode'),\n\t\t\tflags = fs.constants.O_WRONLY | fs.constants.O_CREAT | fs.constants.O_SYNC\n\t\t;\n\t\tlet promises = [];\n\t\tlet results = {};\n\t\tfor (let part in parts) {\n\t\t\tlet filepath = path.join(dir, part);\n\t\t\tif (parts[part] === true) {\n\t\t\t\tresults[part] = fs.createWriteStream(\n\t\t\t\t\tfilepath,\n\t\t\t\t\t{\n\t\t\t\t\t\tflags: flags,\n\t\t\t\t\t\tmode: fileMode\n\t\t\t\t\t}\n\t\t\t\t);\n\t\t\t}\n\t\t\telse if (parts[part] instanceof stream.Readable) {\n\t\t\t\tpromises.push(new Promise((resolve, reject) => {\n\t\t\t\t\tlet writer = fs.createWriteStream(\n\t\t\t\t\t\tfilepath,\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tflags: flags,\n\t\t\t\t\t\t\tmode: fileMode\n\t\t\t\t\t\t}\n\t\t\t\t\t);\n\t\t\t\t\twriter.on('error', (err) => {\n\t\t\t\t\t\treject(err);\n\t\t\t\t\t});\n\t\t\t\t\t/* readers have 'end', writers have 'finish' */\n\t\t\t\t\twriter.on('finish', () => {\n\t\t\t\t\t\tresolve();\n\t\t\t\t\t});\n\t\t\t\t\tparts[part].pipe(writer);\n\t\t\t\t\tresults[part] = true;\n\t\t\t\t}));\n\t\t\t}\n\t\t\telse {\n\t\t\t\tpromises.push(new Promise((resolve, reject) => {\n\t\t\t\t\tfs.writeFile(\n\t\t\t\t\t\tfilepath,\n\t\t\t\t\t\tparts[part],\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tflags: flags,\n\t\t\t\t\t\t\tmode: fileMode\n\t\t\t\t\t\t},\n\t\t\t\t\t\t(err) => {\n\t\t\t\t\t\t\tif (err) {\n\t\t\t\t\t\t\t\treject(err);\n\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tresults[part] = true;\n\t\t\t\t\t\t\tresolve();\n\t\t\t\t\t\t}\n\t\t\t\t\t);\n\t\t\t\t}));\n\t\t\t}\n\t\t}\n\t\tawait Promise.all(promises);\n\t\treturn results;\n\t}\n\n\t/**\n\t * Delete multiple record parts\n\t *\n\t * Parts that do not exist are ignored (not treated as an error).\n\t *\n\t * @param {array} parts - part names to remove\n\t * @returns {Promise<array>} part names deleted\n\t */\n\tasync deleteMultipleParts(parts) {\n\t\tconst\n\t\t\tdir = await this.dir(false),\n\t\t\tpath = this.store.path,\n\t\t\tfs  = this.store.fs\n\t\t;\n\t\tif (!(parts instanceof Array)) {\n\t\t\tparts = Object.keys(parts);\n\t\t}\n\t\tlet promises = [];\n\t\tlet results = [];\n\t\tfor (let part of parts) {\n\t\t\tpromises.push(new Promise(async (resolve, reject) => {\n\t\t\t\tfs.unlink(\n\t\t\t\t\tpath.join(dir, part),\n\t\t\t\t\t(err) => {\n\t\t\t\t\t\tif (err) {\n\t\t\t\t\t\t\tif (err.code == 'ENOENT') {\n\t\t\t\t\t\t\t\tresolve();\n\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treject(err);\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tresults.push(part);\n\t\t\t\t\t\tresolve();\n\t\t\t\t\t}\n\t\t\t\t);\n\t\t\t}));\n\t\t}\n\t\tresults.sort();\n\t\tpromises.push((async () => {\n\t\t\tlet removeDir = dir;\n\t\t\tfor (let i = 0; i < 6; i++) {\n\t\t\t\tawait new Promise((resolve) => {\n\t\t\t\t\tfs.rmdir(removeDir, (err) => {\n\t\t\t\t\t\tif (err) {\n\t\t\t\t\t\t\ti = 6;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tresolve();\n\t\t\t\t\t});\n\t\t\t\t});\n\t\t\t\tremoveDir = path.dirname(removeDir);\n\t\t\t}\n\t\t})());\n\t\tawait Promise.all(promises);\n\t\treturn results;\n\t}\n\n\t/**\n\t * Overwrite contents of multiple record parts\n\t *\n\t * @param {array} parts - part names to shred\n\t * @returns {Promise<void>}\n\t */\n\tasync shredMultipleParts(parts) {\n\t\tconst\n\t\t\tdir = await this.dir(false),\n\t\t\tpath = this.store.path,\n\t\t\tfs  = this.store.fs,\n\t\t\tshred = this.store.option('shredFunction'),\n\t\t\tfileMode = this.store.option('fileMode'),\n\t\t\tflags = fs.constants.O_WRONLY | fs.constants.O_CREAT | fs.constants.O_SYNC\n\t\t;\n\t\tif (!(parts instanceof Array)) {\n\t\t\tparts = Object.keys(parts);\n\t\t}\n\t\tlet promises = [];\n\t\tfor (let part of parts) {\n\t\t\tpromises.push(new Promise(async (resolve, reject) => {\n\t\t\t\tlet filepath = path.join(dir, part);\n\t\t\t\tfs.stat(\n\t\t\t\t\tfilepath,\n\t\t\t\t\t(err, stat) => {\n\t\t\t\t\t\tif (err) {\n\t\t\t\t\t\t\treject(err);\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tlet bytesRemaining = stat.size;\n\t\t\t\t\t\tlet reader = new stream.Readable({\n\t\t\t\t\t\t\tautoDestroy: true,\n\t\t\t\t\t\t\tread(size) {\n\t\t\t\t\t\t\t\tlet go = true;\n\t\t\t\t\t\t\t\twhile(go && bytesRemaining) {\n\t\t\t\t\t\t\t\t\tif (bytesRemaining <= size) {\n\t\t\t\t\t\t\t\t\t\tsize = bytesRemaining;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tgo = this.push(shred(size));\n\t\t\t\t\t\t\t\t\tbytesRemaining -= size;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (bytesRemaining == 0) {\n\t\t\t\t\t\t\t\t\tthis.push(null);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\t\t\t\t\t\tlet writer = fs.createWriteStream(\n\t\t\t\t\t\t\tfilepath,\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tflags: flags,\n\t\t\t\t\t\t\t\tmode: fileMode\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t);\n\t\t\t\t\t\twriter.on('error', (err) => {\n\t\t\t\t\t\t\treject(err);\n\t\t\t\t\t\t});\n\t\t\t\t\t\twriter.on('finish', () => {\n\t\t\t\t\t\t\tresolve();\n\t\t\t\t\t\t});\n\t\t\t\t\t\treader.pipe(writer);\n\t\t\t\t\t}\n\t\t\t\t);\n\t\t\t}));\n\t\t}\n\t\treturn Promise.all(promises);\n\t}\n\n\n\t// Convenience methods\n\n\t/**\n\t * Return file stat data for part\n\t *\n\t * @param {?string} part - name of part, or null for default part\n\t * @returns {Promise<fs.Stats>} stat results\n\t */\n\tasync statPart(part = null) {\n\t\treturn this._singlePartOperation('statMultipleParts', part, false);\n\t}\n\n\t/**\n\t * Read a record part into a buffer\n\t *\n\t * @param {?string} part - name of part, or null for default part\n\t * @returns {Promise<Buffer>} content\n\t */\n\tasync readBuffer(part = null) {\n\t\treturn this._singlePartOperation('readMultipleParts', part, false);\n\t}\n\n\t/**\n\t * Write a record part from a buffer\n\t *\n\t * @param {?string} part - name of part, or null for default part\n\t * @param {(Buffer|string)} content - content to write to part\n\t * @returns {Promise<void>}\n\t */\n\tasync writeBuffer(part, content) {\n\t\treturn this._singlePartOperation('writeMultipleParts', part, content);\n\t}\n\n\t/**\n\t * Get a stream reader for a record part\n\t *\n\t * @param {?string} part - name of part, or null for default part\n\t * @returns {Promise<fs.ReadStream>}\n\t */\n\tasync readStream(part = null) {\n\t\treturn this._singlePartOperation('readMultipleParts', part, true);\n\t}\n\n\t/**\n\t * Get a stream writer for a record part\n\t *\n\t * @param {?string} part - name of part, or null for default part\n\t * @returns {Promise<fs.WriteStream>}\n\t */\n\tasync writeStream(part = null) {\n\t\treturn this._singlePartOperation('writeMultipleParts', part, true);\n\t}\n\n\t/**\n\t * Delete a record part\n\t *\n\t * @param {?string} part - name of part, or null for default part\n\t * @returns {Promise<bool>} true if part existed and was deleted, false if it did not exist\n\t */\n\tasync deletePart(part = null) {\n\t\treturn this._singlePartOperation('deleteMultipleParts', part, null);\n\t}\n\n\t/**\n\t * Delete entire record (delete all record parts)\n\t *\n\t * @returns {Promise<array>} removed part names\n\t */\n\tasync deleteAll() {\n\t\treturn this.deleteMultipleParts(await this.listParts());\n\t}\n\n\t/**\n\t * Overwrite part contents\n\t *\n\t * @param {?string} part - name of part, or null for default part\n\t * @returns {Promise<void>}\n\t */\n\tasync shredPart(part = null) {\n\t\treturn this._singlePartOperation('shredMultipleParts', part, null);\n\t}\n\n\n\t// Internal methods\n\n\t/**\n\t * Convert convenience single-part operation into multiple-part operation\n\t * @access private\n\t */\n\tasync _singlePartOperation(method, part, value) {\n\t\tpart = part || this.store.option('defaultPart');\n\t\tlet parts = {};\n\t\tparts[part] = value;\n\t\tparts = await this[method](parts);\n\t\tif (Array.isArray(parts)) {\n\t\t\treturn parts.length ? true : false;\n\t\t}\n\t\tif (typeof parts == 'object') {\n\t\t\treturn parts[part];\n\t\t}\n\t\treturn null;\n\t}\n};\n",
    "static": true,
    "longname": "/Users/ky/Documents/local/morvren-achronos/code/fs-atomic-data-store/src/Record.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 84,
    "kind": "variable",
    "name": "stream",
    "memberof": "src/Record.js",
    "static": true,
    "longname": "src/Record.js~stream",
    "access": "public",
    "export": false,
    "importPath": "fs-atomic-data-store/src/Record.js",
    "importStyle": null,
    "description": "class Record",
    "lineNumber": 6,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 85,
    "kind": "class",
    "name": "Record",
    "memberof": "src/Record.js",
    "static": true,
    "longname": "src/Record.js~Record",
    "access": "public",
    "export": true,
    "importPath": "fs-atomic-data-store/src/Record.js",
    "importStyle": "Record",
    "description": "Interact with a record\n\nDo not instantiate this class directly, use methods from class {Store}",
    "lineNumber": 13,
    "interface": false
  },
  {
    "__docId__": 86,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/Record.js~Record",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Record.js~Record#constructor",
    "access": "public",
    "description": "Get record interaction instance",
    "lineNumber": 21,
    "params": [
      {
        "nullable": null,
        "types": [
          "Store"
        ],
        "spread": false,
        "optional": false,
        "name": "store",
        "description": "object"
      },
      {
        "nullable": null,
        "types": [
          "Collection"
        ],
        "spread": false,
        "optional": false,
        "name": "collection",
        "description": "object"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "identifier",
        "description": "record identifier"
      }
    ]
  },
  {
    "__docId__": 87,
    "kind": "member",
    "name": "_store",
    "memberof": "src/Record.js~Record",
    "static": false,
    "longname": "src/Record.js~Record#_store",
    "access": "private",
    "description": "",
    "lineNumber": 25,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 88,
    "kind": "member",
    "name": "_col",
    "memberof": "src/Record.js~Record",
    "static": false,
    "longname": "src/Record.js~Record#_col",
    "access": "private",
    "description": "",
    "lineNumber": 29,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 89,
    "kind": "member",
    "name": "_id",
    "memberof": "src/Record.js~Record",
    "static": false,
    "longname": "src/Record.js~Record#_id",
    "access": "private",
    "description": "",
    "lineNumber": 33,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 90,
    "kind": "get",
    "name": "store",
    "memberof": "src/Record.js~Record",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Record.js~Record#store",
    "access": "public",
    "description": "Store instance for this record",
    "lineNumber": 44,
    "type": {
      "nullable": null,
      "types": [
        "Store"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 91,
    "kind": "get",
    "name": "collection",
    "memberof": "src/Record.js~Record",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Record.js~Record#collection",
    "access": "public",
    "description": "Collection instance for this record",
    "lineNumber": 53,
    "type": {
      "nullable": null,
      "types": [
        "Collection"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 92,
    "kind": "get",
    "name": "identifier",
    "memberof": "src/Record.js~Record",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Record.js~Record#identifier",
    "access": "public",
    "description": "Identifier for this record",
    "lineNumber": 62,
    "type": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 93,
    "kind": "method",
    "name": "generateHash",
    "memberof": "src/Record.js~Record",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Record.js~Record#generateHash",
    "access": "public",
    "description": "Return hex-encoded 32-bit unsigned integer hash of record identifier\n\nBased on npm module string-hash (https://github.com/darkskyapp/string-hash) by The Dark Sky Company, LLC\nThat code is licensed under CC0-1.0",
    "lineNumber": 74,
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": "8-character hex encoding of hash"
    },
    "params": []
  },
  {
    "__docId__": 94,
    "kind": "method",
    "name": "dir",
    "memberof": "src/Record.js~Record",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "src/Record.js~Record#dir",
    "access": "public",
    "description": "Get directory path of record\n\nDirectory is created if it doesn't exist.",
    "lineNumber": 98,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise<string>} dirpath"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "bool"
        ],
        "spread": false,
        "optional": false,
        "name": "create",
        "description": "true to create directory if it does not exist"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise<string>"
      ],
      "spread": false,
      "description": "dirpath"
    }
  },
  {
    "__docId__": 95,
    "kind": "method",
    "name": "filepath",
    "memberof": "src/Record.js~Record",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "src/Record.js~Record#filepath",
    "access": "public",
    "description": "Get file path of record part",
    "lineNumber": 116,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise<string>} filepath"
      }
    ],
    "params": [
      {
        "nullable": true,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "part",
        "description": "name of part, or null for default part"
      },
      {
        "nullable": null,
        "types": [
          "bool"
        ],
        "spread": false,
        "optional": false,
        "name": "createDir",
        "description": "true to create directory if it does not exist"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise<string>"
      ],
      "spread": false,
      "description": "filepath"
    }
  },
  {
    "__docId__": 96,
    "kind": "method",
    "name": "listParts",
    "memberof": "src/Record.js~Record",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "src/Record.js~Record#listParts",
    "access": "public",
    "description": "Get list of record parts",
    "lineNumber": 131,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise<array>} partnames"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise<array>"
      ],
      "spread": false,
      "description": "partnames"
    },
    "params": []
  },
  {
    "__docId__": 97,
    "kind": "method",
    "name": "statMultipleParts",
    "memberof": "src/Record.js~Record",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "src/Record.js~Record#statMultipleParts",
    "access": "public",
    "description": "Get file stat data for multiple record parts",
    "lineNumber": 169,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise<object>} results. Property name is part name. Property value is {fs.Stats}"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "array"
        ],
        "spread": false,
        "optional": false,
        "name": "parts",
        "description": "part names to remove"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise<object>"
      ],
      "spread": false,
      "description": "results. Property name is part name. Property value is {fs.Stats}"
    }
  },
  {
    "__docId__": 98,
    "kind": "method",
    "name": "readMultipleParts",
    "memberof": "src/Record.js~Record",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "src/Record.js~Record#readMultipleParts",
    "access": "public",
    "description": "Read multiple record parts",
    "lineNumber": 208,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise<object>} results. Property name is part name. Property value is {Buffer} or {fs.ReadStream} or {bool true}"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "array",
          "object"
        ],
        "spread": false,
        "optional": false,
        "name": "parts",
        "description": "{array} of part names to read, each is returned in Buffer. Or, {object} of part names and handling instructions:"
      },
      {
        "nullable": null,
        "types": [
          "bool false"
        ],
        "spread": false,
        "optional": false,
        "name": "parts.__partname__",
        "description": "return content in Buffer"
      },
      {
        "nullable": null,
        "types": [
          "bool true"
        ],
        "spread": false,
        "optional": false,
        "name": "parts.__partname__",
        "description": "return ReadStream"
      },
      {
        "nullable": null,
        "types": [
          "stream.Writable"
        ],
        "spread": false,
        "optional": false,
        "name": "parts.__partname__",
        "description": "pipe part content to this stream"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise<object>"
      ],
      "spread": false,
      "description": "results. Property name is part name. Property value is {Buffer} or {fs.ReadStream} or {bool true}"
    }
  },
  {
    "__docId__": 99,
    "kind": "method",
    "name": "writeMultipleParts",
    "memberof": "src/Record.js~Record",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "src/Record.js~Record#writeMultipleParts",
    "access": "public",
    "description": "Write multiple record parts",
    "lineNumber": 276,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise<object>} results. Property name is part name. Property value is {bool true} or {fs.WriteStream}"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": false,
        "name": "parts",
        "description": "part names and contents to write. Each property is a part to write. Property name is part name. Property value specifies part contents"
      },
      {
        "nullable": null,
        "types": [
          "Buffer",
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "parts.__partname__",
        "description": "contents to write"
      },
      {
        "nullable": null,
        "types": [
          "stream.Readable"
        ],
        "spread": false,
        "optional": false,
        "name": "parts.__partname__",
        "description": "pipe part contents from this stream"
      },
      {
        "nullable": null,
        "types": [
          "bool true"
        ],
        "spread": false,
        "optional": false,
        "name": "parts.__partname__",
        "description": "return {fs.WriteStream}"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise<object>"
      ],
      "spread": false,
      "description": "results. Property name is part name. Property value is {bool true} or {fs.WriteStream}"
    }
  },
  {
    "__docId__": 100,
    "kind": "method",
    "name": "deleteMultipleParts",
    "memberof": "src/Record.js~Record",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "src/Record.js~Record#deleteMultipleParts",
    "access": "public",
    "description": "Delete multiple record parts\n\nParts that do not exist are ignored (not treated as an error).",
    "lineNumber": 350,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise<array>} part names deleted"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "array"
        ],
        "spread": false,
        "optional": false,
        "name": "parts",
        "description": "part names to remove"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise<array>"
      ],
      "spread": false,
      "description": "part names deleted"
    }
  },
  {
    "__docId__": 101,
    "kind": "method",
    "name": "shredMultipleParts",
    "memberof": "src/Record.js~Record",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "src/Record.js~Record#shredMultipleParts",
    "access": "public",
    "description": "Overwrite contents of multiple record parts",
    "lineNumber": 405,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise<void>}"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "array"
        ],
        "spread": false,
        "optional": false,
        "name": "parts",
        "description": "part names to shred"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise<void>"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 102,
    "kind": "method",
    "name": "statPart",
    "memberof": "src/Record.js~Record",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "src/Record.js~Record#statPart",
    "access": "public",
    "description": "Return file stat data for part",
    "lineNumber": 475,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise<fs.Stats>} stat results"
      }
    ],
    "params": [
      {
        "nullable": true,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "part",
        "description": "name of part, or null for default part"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise<fs.Stats>"
      ],
      "spread": false,
      "description": "stat results"
    }
  },
  {
    "__docId__": 103,
    "kind": "method",
    "name": "readBuffer",
    "memberof": "src/Record.js~Record",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "src/Record.js~Record#readBuffer",
    "access": "public",
    "description": "Read a record part into a buffer",
    "lineNumber": 485,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise<Buffer>} content"
      }
    ],
    "params": [
      {
        "nullable": true,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "part",
        "description": "name of part, or null for default part"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise<Buffer>"
      ],
      "spread": false,
      "description": "content"
    }
  },
  {
    "__docId__": 104,
    "kind": "method",
    "name": "writeBuffer",
    "memberof": "src/Record.js~Record",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "src/Record.js~Record#writeBuffer",
    "access": "public",
    "description": "Write a record part from a buffer",
    "lineNumber": 496,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise<void>}"
      }
    ],
    "params": [
      {
        "nullable": true,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "part",
        "description": "name of part, or null for default part"
      },
      {
        "nullable": null,
        "types": [
          "Buffer",
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "content",
        "description": "content to write to part"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise<void>"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 105,
    "kind": "method",
    "name": "readStream",
    "memberof": "src/Record.js~Record",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "src/Record.js~Record#readStream",
    "access": "public",
    "description": "Get a stream reader for a record part",
    "lineNumber": 506,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise<fs.ReadStream>}"
      }
    ],
    "params": [
      {
        "nullable": true,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "part",
        "description": "name of part, or null for default part"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise<fs.ReadStream>"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 106,
    "kind": "method",
    "name": "writeStream",
    "memberof": "src/Record.js~Record",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "src/Record.js~Record#writeStream",
    "access": "public",
    "description": "Get a stream writer for a record part",
    "lineNumber": 516,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise<fs.WriteStream>}"
      }
    ],
    "params": [
      {
        "nullable": true,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "part",
        "description": "name of part, or null for default part"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise<fs.WriteStream>"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 107,
    "kind": "method",
    "name": "deletePart",
    "memberof": "src/Record.js~Record",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "src/Record.js~Record#deletePart",
    "access": "public",
    "description": "Delete a record part",
    "lineNumber": 526,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise<bool>} true if part existed and was deleted, false if it did not exist"
      }
    ],
    "params": [
      {
        "nullable": true,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "part",
        "description": "name of part, or null for default part"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise<bool>"
      ],
      "spread": false,
      "description": "true if part existed and was deleted, false if it did not exist"
    }
  },
  {
    "__docId__": 108,
    "kind": "method",
    "name": "deleteAll",
    "memberof": "src/Record.js~Record",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "src/Record.js~Record#deleteAll",
    "access": "public",
    "description": "Delete entire record (delete all record parts)",
    "lineNumber": 535,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise<array>} removed part names"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise<array>"
      ],
      "spread": false,
      "description": "removed part names"
    },
    "params": []
  },
  {
    "__docId__": 109,
    "kind": "method",
    "name": "shredPart",
    "memberof": "src/Record.js~Record",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "src/Record.js~Record#shredPart",
    "access": "public",
    "description": "Overwrite part contents",
    "lineNumber": 545,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise<void>}"
      }
    ],
    "params": [
      {
        "nullable": true,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "part",
        "description": "name of part, or null for default part"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise<void>"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 110,
    "kind": "method",
    "name": "_singlePartOperation",
    "memberof": "src/Record.js~Record",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "src/Record.js~Record#_singlePartOperation",
    "access": "private",
    "description": "Convert convenience single-part operation into multiple-part operation",
    "lineNumber": 556,
    "params": [
      {
        "name": "method",
        "types": [
          "*"
        ]
      },
      {
        "name": "part",
        "types": [
          "*"
        ]
      },
      {
        "name": "value",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 111,
    "kind": "file",
    "name": "src/Store.js",
    "content": "/**\n * class Store\n */\n\n/**\n * Interact with a datastore\n */\nmodule.exports = class Store {\n\t/**\n\t * Create new Store instance\n\t *\n\t * @param {object} options\n\t * @param {string} options.dirPath - root directory for this store. Default is subdirectory \"store\" in current working directory\n\t * @param {number} options.fileMode - octal file permission mode when creating files. Default 0o660\n\t * @param {number} options.dirMode - octal file permission mode when creating directories. Default 0o770\n\t * @param {string} options.defaultPart - default part name to use when none is specified. Default \"r\"\n\t * @param {module} options.fsModule - use this instead of Node.js builtin fs (filesystem) module\n\t * @param {module} options.pathModule- use this instead of Node.js buitin path (filepaths) module\n\t * @param {function} options.recordClass - use this instead of internal Record class\n\t * @param {function} options.collectionClass -  use this instead of internal Collection class\n\t * @param {function} options.lockClass - use this instead of internal Lock class\n\t * @param {function} options.shredFunction - use this to generate overwrite data when shredding record parts. Default is crypto.randomBytes. Signature: `function(size): Buffer`\n\t */\n\tconstructor(options = {}) {\n\t\t/**\n\t\t * @access private\n\t\t */\n\t\tthis._options = {\n\t\t\trootDir: 'store',\n\t\t\tfileMode: 0o660,\n\t\t\tdirMode: 0o770,\n\t\t\tdefaultPart: 'r',\n\t\t\tfsModule: 'fs',\n\t\t\tpathModule: 'path',\n\t\t\trecordClass: './Record',\n\t\t\tcollectionClass: './Collection',\n\t\t\tlockClass: './Lock',\n\t\t\tshredFunction: null,\n\t\t\trecordsDir: 'records',\n\t\t\tlocksDir: 'locks'\n\t\t};\n\t\t/**\n\t\t * @access private\n\t\t */\n\t\tthis._collections = {};\n\n\t\tif (typeof options == 'object') {\n\t\t\tfor (let k in options) {\n\t\t\t\tif (this._options[k] !== undefined) {\n\t\t\t\t\tthis._options[k] = options[k];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (let k of ['fsModule', 'pathModule', 'recordClass', 'collectionClass', 'lockClass']) {\n\t\t\tif (typeof this._options[k] == 'string') {\n\t\t\t\tthis._options[k] = require(this._options[k]);\n\t\t\t}\n\t\t}\n\t\tif (this._options.shredFunction == null) {\n\t\t\tthis._options.shredFunction = require('crypto').randomBytes;\n\t\t}\n\t}\n\n\n\t// Utility methods\n\n\t/**\n\t * Filesystem module\n\t *\n\t * @type {module}\n\t */\n\tget fs() {\n\t\treturn this.option('fsModule');\n\t}\n\n\t/**\n\t * Filepaths module\n\t *\n\t * @type {module}\n\t */\n\tget path() {\n\t\treturn this.option('pathModule');\n\t}\n\n\t/**\n\t * Return a configured option\n\t *\n\t * @param {string} name - option property name\n\t * @returns {*} option value\n\t */\n\toption(name) {\n\t\treturn this._options[name];\n\t}\n\n\t/**\n\t * Get directory path within store\n\t *\n\t * Directory is created if it doesn't exist.\n\t *\n\t * @param {array} dirParts - dir path components\n\t * @param {bool} create - true to create directory if it does not exist\n\t * @returns {Promise<s?tring>} dirpath\n\t */\n\tasync dir(dirParts = [], create = true) {\n\t\tconst\n\t\t\tpath = this.path,\n\t\t\tfs  = this.fs,\n\t\t\tdir = path.resolve(this.option('rootDir'), ...dirParts)\n\t\t;\n\t\treturn new Promise((resolve, reject) => {\n\t\t\tfs.access(\n\t\t\t\tdir,\n\t\t\t\tfs.constants.R_OK | fs.constants.W_OK | fs.constants.X_OK,\n\t\t\t\t(err) => {\n\t\t\t\t\tif (!err) {\n\t\t\t\t\t\tresolve(dir);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tif (err.code != 'ENOENT') {\n\t\t\t\t\t\treject(err);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tif (!create) {\n\t\t\t\t\t\tresolve(dir);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tfs.mkdir(\n\t\t\t\t\t\tdir,\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\trecursive: true,\n\t\t\t\t\t\t\tmode: this.option('dirMode')\n\t\t\t\t\t\t},\n\t\t\t\t\t\t(err) => {\n\t\t\t\t\t\t\tif (err && err.code != 'EEXIST') {\n\t\t\t\t\t\t\t\treject(err);\n\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tresolve(dir);\n\t\t\t\t\t\t}\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t);\n\t\t});\n\t}\n\n\n\t// Factory methods\n\n\t/**\n\t * Return an object to interact with a named collection of records\n\t *\n\t * @param {string} name - collection name\n\t * @returns {Collection} collection object\n\t */\n\tcollection(name) {\n\t\tname = name.toLowerCase();\n\t\tif (!this._collections[name]) {\n\t\t\tthis._collections[name] = new (this.option('collectionClass'))(this, name);\n\t\t}\n\t\treturn this._collections[name];\n\t}\n\n\t/**\n\t * Return an object to interact with a record\n\t *\n\t * @param {string} collection - collection name\n\t * @param {string} identifier - record identifier\n\t * @returns {Record} record object\n\t */\n\trecord(collection, identifier) {\n\t\treturn this.collection(collection).record(identifier);\n\t}\n\n\t/**\n\t * Return an object to perform exclusive access locking\n\t *\n\t * @param {object} options - see Lock class\n\t * @returns {Lock} locking instance\n\t */\n\tlock(options = {}) {\n\t\treturn new (this.option('lockClass'))(this, options);\n\t}\n\n\n\t// Data operation methods\n\n\t/**\n\t * Perform a sequence of operations requiring exclusive access\n\t *\n\t * The operation should request exclusive locks using the provided instance of the Lock class.\n\t * If a lock cannot be applied, the entire transaction will fail.\n\t * The operation code must structure calls to ensure that it holds all needed locks prior to making any data changes or assumptions about the immutability of loaded records.\n\t *\n\t * By default, no attempt is made to retry if a lock is not available.\n\t * Likewise, no attempt is made to retry the entire transaction if any lock is unavailable.\n\t * Both individual locks and the transaction as a whole can be configured to retry automatically after a delay.\n\t * The delay before the first transaction retry is specified by the `retryWait` option.\n\t * The maximum total transaction retry delay is specified by the `retryTimeout` option.\n\t *\n\t * @param {function} callback - perform operations; may be called multiple times, may be halted at any point where a lock is acquired\n\t *   Signature: `async function(lockObject, storeObject, tryCount): Promise<*>`\n\t * @param {object} options\n\t * @param {number} options.retryTimeout int maximum milliseconds to retry transaction until giving up, default 0 (no retry)\n\t * @param {number} options.retryWait int minimum milliseconds before first transaction retry, default 10 ms.\n\t * @param {number} options.lockTimeout int maximum milliseconds to retry each lock until giving up, default 0 (no retry)\n\t * @param {number} options.lockWait int minimum milliseconds before first lock retry, default 10 ms\n\t * @returns {Promise<*>} On success, resolves with result of callback function's promise. On failure due to lock conflict, rejects with code 'ELOCKED'\n\t */\n\tasync transaction(callback, options = {}) {\n\t\toptions.retryTimeout = parseInt(options.retryTimeout, 10) || 0;\n\t\toptions.retryWait = parseInt(options.retryWait, 10) || 10;\n\t\toptions.lockTimeout = parseInt(options.lockTimeout, 10) || 0;\n\t\toptions.lockWait = parseInt(options.lockWait, 10) || 10;\n\n\t\tconst lock = this.lock(this, {\n\t\t\ttimeout: options.lockTimeout,\n\t\t\twait: options.lockWait\n\t\t});\n\t\treturn lock.runWithRetry(\n\t\t\t(resolve, reject, retry, tryCount) => {\n\t\t\t\tcallback(lock, this, tryCount)\n\t\t\t\t\t.then((result) => {\n\t\t\t\t\t\tlock.unlockAll();\n\t\t\t\t\t\tresolve(result);\n\t\t\t\t\t})\n\t\t\t\t\t.catch((err) => {\n\t\t\t\t\t\tlock.unlockAll();\n\t\t\t\t\t\tif (err.code != 'ELOCKED') {\n\t\t\t\t\t\t\treject(err);\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tretry();\n\t\t\t\t\t})\n\t\t\t\t;\n\t\t\t},\n\t\t\t(originalErr) => {\n\t\t\t\tconst err = new Error('Error: ELOCKED: unable to acquire locks');\n\t\t\t\terr.code = 'ELOCKED';\n\t\t\t\terr.lockType = 'transaction';\n\t\t\t\terr.cause = originalErr;\n\t\t\t\treturn err;\n\t\t\t},\n\t\t\t{\n\t\t\t\ttimeout: options.retryTimeout,\n\t\t\t\twait: options.retryWait\n\t\t\t}\n\t\t);\n\t}\n};\n",
    "static": true,
    "longname": "/Users/ky/Documents/local/morvren-achronos/code/fs-atomic-data-store/src/Store.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 112,
    "kind": "class",
    "name": "Store",
    "memberof": "src/Store.js",
    "static": true,
    "longname": "src/Store.js~Store",
    "access": "public",
    "export": true,
    "importPath": "fs-atomic-data-store/src/Store.js",
    "importStyle": "Store",
    "description": "Interact with a datastore",
    "lineNumber": 8,
    "interface": false
  },
  {
    "__docId__": 113,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/Store.js~Store",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Store.js~Store#constructor",
    "access": "public",
    "description": "Create new Store instance",
    "lineNumber": 24,
    "params": [
      {
        "nullable": null,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": false,
        "name": "options",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "options.dirPath",
        "description": "root directory for this store. Default is subdirectory \"store\" in current working directory"
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "options.fileMode",
        "description": "octal file permission mode when creating files. Default 0o660"
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "options.dirMode",
        "description": "octal file permission mode when creating directories. Default 0o770"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "options.defaultPart",
        "description": "default part name to use when none is specified. Default \"r\""
      },
      {
        "nullable": null,
        "types": [
          "module"
        ],
        "spread": false,
        "optional": false,
        "name": "options.fsModule",
        "description": "use this instead of Node.js builtin fs (filesystem) module"
      },
      {
        "nullable": null,
        "types": [
          "module"
        ],
        "spread": false,
        "optional": false,
        "name": "options.pathModule-",
        "description": "use this instead of Node.js buitin path (filepaths) module"
      },
      {
        "nullable": null,
        "types": [
          "function"
        ],
        "spread": false,
        "optional": false,
        "name": "options.recordClass",
        "description": "use this instead of internal Record class"
      },
      {
        "nullable": null,
        "types": [
          "function"
        ],
        "spread": false,
        "optional": false,
        "name": "options.collectionClass",
        "description": "use this instead of internal Collection class"
      },
      {
        "nullable": null,
        "types": [
          "function"
        ],
        "spread": false,
        "optional": false,
        "name": "options.lockClass",
        "description": "use this instead of internal Lock class"
      },
      {
        "nullable": null,
        "types": [
          "function"
        ],
        "spread": false,
        "optional": false,
        "name": "options.shredFunction",
        "description": "use this to generate overwrite data when shredding record parts. Default is crypto.randomBytes. Signature: `function(size): Buffer`"
      }
    ]
  },
  {
    "__docId__": 114,
    "kind": "member",
    "name": "_options",
    "memberof": "src/Store.js~Store",
    "static": false,
    "longname": "src/Store.js~Store#_options",
    "access": "private",
    "description": "",
    "lineNumber": 28,
    "type": {
      "types": [
        "{\"rootDir\": string, \"fileMode\": number, \"dirMode\": number, \"defaultPart\": string, \"fsModule\": string, \"pathModule\": string, \"recordClass\": string, \"collectionClass\": string, \"lockClass\": string, \"shredFunction\": *, \"recordsDir\": string, \"locksDir\": string}"
      ]
    }
  },
  {
    "__docId__": 115,
    "kind": "member",
    "name": "_collections",
    "memberof": "src/Store.js~Store",
    "static": false,
    "longname": "src/Store.js~Store#_collections",
    "access": "private",
    "description": "",
    "lineNumber": 45,
    "type": {
      "types": [
        "{}"
      ]
    }
  },
  {
    "__docId__": 116,
    "kind": "get",
    "name": "fs",
    "memberof": "src/Store.js~Store",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Store.js~Store#fs",
    "access": "public",
    "description": "Filesystem module",
    "lineNumber": 72,
    "type": {
      "nullable": null,
      "types": [
        "module"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 117,
    "kind": "get",
    "name": "path",
    "memberof": "src/Store.js~Store",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Store.js~Store#path",
    "access": "public",
    "description": "Filepaths module",
    "lineNumber": 81,
    "type": {
      "nullable": null,
      "types": [
        "module"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 118,
    "kind": "method",
    "name": "option",
    "memberof": "src/Store.js~Store",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Store.js~Store#option",
    "access": "public",
    "description": "Return a configured option",
    "lineNumber": 91,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{*} option value"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "name",
        "description": "option property name"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "*"
      ],
      "spread": false,
      "description": "option value"
    }
  },
  {
    "__docId__": 119,
    "kind": "method",
    "name": "dir",
    "memberof": "src/Store.js~Store",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "src/Store.js~Store#dir",
    "access": "public",
    "description": "Get directory path within store\n\nDirectory is created if it doesn't exist.",
    "lineNumber": 104,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise<s?tring>} dirpath"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "array"
        ],
        "spread": false,
        "optional": false,
        "name": "dirParts",
        "description": "dir path components"
      },
      {
        "nullable": null,
        "types": [
          "bool"
        ],
        "spread": false,
        "optional": false,
        "name": "create",
        "description": "true to create directory if it does not exist"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise<s?tring>"
      ],
      "spread": false,
      "description": "dirpath"
    }
  },
  {
    "__docId__": 120,
    "kind": "method",
    "name": "collection",
    "memberof": "src/Store.js~Store",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Store.js~Store#collection",
    "access": "public",
    "description": "Return an object to interact with a named collection of records",
    "lineNumber": 155,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Collection} collection object"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "name",
        "description": "collection name"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Collection"
      ],
      "spread": false,
      "description": "collection object"
    }
  },
  {
    "__docId__": 121,
    "kind": "method",
    "name": "record",
    "memberof": "src/Store.js~Store",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Store.js~Store#record",
    "access": "public",
    "description": "Return an object to interact with a record",
    "lineNumber": 170,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Record} record object"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "collection",
        "description": "collection name"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "identifier",
        "description": "record identifier"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Record"
      ],
      "spread": false,
      "description": "record object"
    }
  },
  {
    "__docId__": 122,
    "kind": "method",
    "name": "lock",
    "memberof": "src/Store.js~Store",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/Store.js~Store#lock",
    "access": "public",
    "description": "Return an object to perform exclusive access locking",
    "lineNumber": 180,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Lock} locking instance"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": false,
        "name": "options",
        "description": "see Lock class"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Lock"
      ],
      "spread": false,
      "description": "locking instance"
    }
  },
  {
    "__docId__": 123,
    "kind": "method",
    "name": "transaction",
    "memberof": "src/Store.js~Store",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "src/Store.js~Store#transaction",
    "access": "public",
    "description": "Perform a sequence of operations requiring exclusive access\n\nThe operation should request exclusive locks using the provided instance of the Lock class.\nIf a lock cannot be applied, the entire transaction will fail.\nThe operation code must structure calls to ensure that it holds all needed locks prior to making any data changes or assumptions about the immutability of loaded records.\n\nBy default, no attempt is made to retry if a lock is not available.\nLikewise, no attempt is made to retry the entire transaction if any lock is unavailable.\nBoth individual locks and the transaction as a whole can be configured to retry automatically after a delay.\nThe delay before the first transaction retry is specified by the `retryWait` option.\nThe maximum total transaction retry delay is specified by the `retryTimeout` option.",
    "lineNumber": 209,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise<*>} On success, resolves with result of callback function's promise. On failure due to lock conflict, rejects with code 'ELOCKED'"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "function"
        ],
        "spread": false,
        "optional": false,
        "name": "callback",
        "description": "perform operations; may be called multiple times, may be halted at any point where a lock is acquired\n  Signature: `async function(lockObject, storeObject, tryCount): Promise<*>`"
      },
      {
        "nullable": null,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": false,
        "name": "options",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "options.retryTimeout",
        "description": "int maximum milliseconds to retry transaction until giving up, default 0 (no retry)"
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "options.retryWait",
        "description": "int minimum milliseconds before first transaction retry, default 10 ms."
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "options.lockTimeout",
        "description": "int maximum milliseconds to retry each lock until giving up, default 0 (no retry)"
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "options.lockWait",
        "description": "int minimum milliseconds before first lock retry, default 10 ms"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise<*>"
      ],
      "spread": false,
      "description": "On success, resolves with result of callback function's promise. On failure due to lock conflict, rejects with code 'ELOCKED'"
    }
  },
  {
    "kind": "index",
    "content": "# fs-atomic-data-store\n\nkey-record store, uses filesystem, allows any data, transactional\n\n## Overview\n\n### Features\n\n* **key-record store**  \n  Persistent key-value database.  \n  A store is a collection of records, each record has a unique key and one or more values.\n\n* **uses filesystem**    \n  Plain files, nothing fancy.  \n  No external applications or libraries, pure Node.js javascript.\n\n* **allows any data**  \n  A record value can contain anything, no structure is imposed or supplied.  \n  For example this is _not_ a JSON database. You can store JSON if you want, or BSON or YAML or an octet-stream.\n\n* **transactional**  \n  Supports atomic operations across one or multiple records.  \n  You can read-then-write or read-then-delete with assurance that no other actor is operating simultaneously.\n\n### Design goals\n\n* Self-contained. No fancy dependencies, no database engine.\n* No assumptions about stored data. Values are binary buffers.\n* Streaming.\n* No constraints. Throughput and size limitations are provided by the system not the library. Caching is done elsewhere.\n* Atomic locks across processes. OK for simultaneous requests to Node.js, multiple Node.js instances, network/shared filesystems, etc.\n* POSIX-compliant.\n\n### Why use it?\n\n* If you need a persistent key-value store.\n* If your dataset may be large.\n* If individual entries may be large in size.\n* If you need control over how data is serialized (e.g. not being coerced into JSON when you may sometimes need to store big binary files)\n* If you need to guarantee that only one actor is working on a record at a time\n* If you don't need (or will provide your own) automatic magic for caching, change observers, object persistence, etc.\n\n### Why build it?\n\n* We needed a simple storage solution.\n* We didn't need indexes or foreign keys or anything like that, and we didn't want to rely on an external database system without a compelling reason.\n* We need to support both *lots of little records* and *some records being huge binary files*, so storing as e.g. JSON is no good.\n* Basically every module we could find was either tinker-toy or had a baked in record format like JSON. (Whereas we wanted BSON or MessagePack mostly, but sometimes just an octet-stream).\n* So, we built one. Here it is.\n\n### Environment\n\n* Node v10+ series (uses ES6 syntax)\n* Built for Mac and Linux. Any POSIX-compliant system *should* be fine. Windows should be ok in theory although this is completely untested (2019-03).\n* Any filesystem is supported.\n\n## Installation\n\nInstall via npm:\n\n npm install --save fs-atomic-data-store\n\n## Usage\n\n```javascript\nconst fads = require('fs-atomic-data-store');\n\n// Access a store, provide store root directory. Store may or may not exist\nlet mystore = new fads.Store('./path/to/my/store/dir');\n\n// Access a collection by name. Collection may or may not exist\nlet mycollection = mystore.collection('foo');\n\n// Access a record by identifier. Record may or may not exist\nlet myrecord = mycollection.record('bar');\n\n// Read record into Buffer\nmyrecord.readBuffer().then((content) => {\n\tconsole.log('foo.bar contains: ' + content.toString('utf8'));\n});\n```\n## Notes\n\n### Format\n\n* A store is a set of records stored within a directory on the filesystem.\n* Stores are subdivided into named collections.\n* Each collection has a string name.  \n  Names should be 7-bit ASCII, suggested max size of 64 bytes.\n* Each collection has zero or more records.\n* Each record has a string identifier.  \n  Identifiers should be 7-bit ASCII, suggested max size of 200 bytes.  \n  For non-ASCII or binary identifiers, serialize first, e.g. by converting to hex (`mybufferkey.toString('hex')`).\n* Each record has one or more content parts.\n* Each part has a string key (7-bit ASCII, suggested max size 32 bytes).\n* Each part has a binary (buffer) value.\n\n### Locking model\n\nThe use case this model is designed for is one where simultaneous access is expected to be uncommon, but must be absolutely guaranteed to never happen.\n\n* Locks can be established at record level, collection level or \"globally\" at store level.\n* Record locks are guaranteed exclusive and atomic.  \n  No one record can be locked by multiple actors at the same time.  \n  This includes different actors running within the same Node process.\n* Store and collection locks are also guaranteed exclusive and atomic.  \n  Once a global lock is established, no further record locks will be allowed.  \n  To ensure exclusive access to enire store/collection, wait until all existing record locks have been unlocked.\n* Locks are first-come-first-served, non-blocking, non-queued.  \n  If a requested lock is unavailable, fail immediately (default) or retry with escalating delay.  \n  Does not block.  \n  Does not keep a lock request queue, so prioritization for highly-contested resources must be handled by the application.\n\nThe default included locking system is a wrapper around [proper-lockfile](https://www.npmjs.com/package/proper-lockfile).\n\n### Storage on filesystem\n\n* Each collection is a subdirectory within `$dataDir/records`.\n* Each record is a nested subdirectory within the collection directory, path based on a hash of the record identifier.\n* Each record part is stored in a separate plain file within the record directory.\n* Lock data is stored in `$datadir/locks`.\n\n### Backup strategies\n\n* archive tool\n\t* if\n\t\t* write volume is low\n\t\t* a point-in-time snapshot is not absolutely required\n\t\t* you can live with the small chance of catching a record in the middle of a write\n\t* then\n\t\t* use `fsync` or `tar` or your favourite archiving utility\n* store-level lock plus archive tool\n\t* if\n\t\t* you need consistency and don't mind some downtime\n\t* then\n\t\t* establish a store-level lock, wait for other open locks to clear, use `fsync`/`tar`/etc., then remove the store-level lock\n* traversal script\n\t* if\n\t\t* downtime is no good\n\t\t* even small chance of one corrupted record in archive is no good\n\t\t* you don't need a point-in-time snapshot\n\t* then\n\t\t* write a program to traverse the store, for each record lock then copy/add to archive then unlock\n* snapshotting filesystem\n\t* if\n\t\t* you need a real point-in-time snapshot\n\t\t* and no downtime\n\t\t* and no corrupted records in archive from bad reads\n\t\t* and a pony\n\t* then\n\t\t* use a snapshotting filesystem\n\t\t* and the power of wishes\n",
    "longname": "/Users/ky/Documents/local/morvren-achronos/code/fs-atomic-data-store/README.md",
    "name": "./README.md",
    "static": true,
    "access": "public"
  },
  {
    "kind": "packageJSON",
    "content": "{\n  \"name\": \"fs-atomic-data-store\",\n  \"version\": \"0.0.1\",\n  \"description\": \"key-record store, allows any data, uses filesystem, supports transactions\",\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"github:morvren-achronos/node-fs-atomic-data-store\"\n  },\n  \"keywords\": [\n    \"storage\",\n    \"file\",\n    \"filesystem\",\n    \"nosql\",\n    \"key-store\",\n    \"atomic\",\n    \"transactional\"\n  ],\n  \"author\": \"Ky Patterson Morvren-Achronos <ky@morvren-achronos.com>\",\n  \"license\": \"Apache-2.0\",\n  \"main\": \"index.js\",\n  \"directories\": {\n    \"lib\": \"src\",\n    \"doc\": \"doc\",\n    \"test\": \"test\"\n  },\n  \"scripts\": {\n    \"test\": \"mocha\",\n    \"doc\": \"esdoc\",\n    \"lint\": \"eslint ./src ./test\"\n  },\n  \"dependencies\": {\n    \"node\": \"^10.10.0\",\n    \"proper-lockfile\": \"^4.0.0\"\n  },\n  \"devDependencies\": {\n    \"chai\": \"^4.2.0\",\n    \"chai-as-promised\": \"^7.1.1\",\n    \"esdoc\": \"^1.1.0\",\n    \"esdoc-node\": \"^1.0.4\",\n    \"esdoc-standard-plugin\": \"^1.0.0\",\n    \"eslint\": \"^5.15.2\",\n    \"mocha\": \"^5.2.0\",\n    \"rimraf\": \"^2.6.3\"\n  },\n  \"esdoc\": {\n    \"source\": \"./src\",\n    \"destination\": \"./doc\",\n    \"plugins\": [\n      {\n        \"name\": \"esdoc-standard-plugin\",\n        \"option\": {\n          \"test\": {\n            \"source\": \"./test/\",\n            \"interfaces\": [\n              \"describe\",\n              \"it\",\n              \"context\",\n              \"suite\",\n              \"test\"\n            ]\n          }\n        }\n      },\n      {\n        \"name\": \"esdoc-node\"\n      }\n    ]\n  }\n}\n",
    "longname": "/Users/ky/Documents/local/morvren-achronos/code/fs-atomic-data-store/package.json",
    "name": "package.json",
    "static": true,
    "access": "public"
  }
]