#!/usr/bin/env node

// Libraries
const
	fsads = require('../index'),
	child_process = require('child_process'),
	crypto = require('crypto'),
	fs = require('fs'),
	os = require('os'),
	path = require('path'),
	rimraf = require('rimraf')
;

// Constants
const RANDOM_SIZE = 16;
const REPEAT_COUNT = 64; // 4096 bytes

if (process.getuid() != 0) {
	console.warn('You are not root. You will probably need to be root for this to work.');
}

let timer = setTimeout(
	() => {
		console.log('still running...');
	},
	10 * 1000
);

const rootDir = fs.realpathSync(fs.mkdtempSync(path.join(os.tmpdir(), '/node-fs-atomic-data-store-check-shred-')));
let devicefd;

async function run() {
	const patternExists = 'fs-atomic-data-store-check-shred' + crypto.randomBytes(RANDOM_SIZE).toString('hex');
	const patternDeleted = 'fs-atomic-data-store-check-shred' + crypto.randomBytes(RANDOM_SIZE).toString('hex');
	const patternShredded = 'fs-atomic-data-store-check-shred' + crypto.randomBytes(RANDOM_SIZE).toString('hex');
	const store = new fsads.Store({rootDir: rootDir});
	const record = store.record('testcol', 'testrec');

	await record.writeBuffer('partExists', patternExists.repeat(REPEAT_COUNT));
	await record.writeBuffer('partDeleted', patternDeleted.repeat(REPEAT_COUNT));
	await record.writeBuffer('partShredded', patternShredded.repeat(REPEAT_COUNT));
	let bufferExists = await record.readBuffer('partExists');
	let bufferDeleted = await record.readBuffer('partDeleted');
	let bufferShredded = await record.readBuffer('partShredded');
	if (
		bufferExists.toString('utf8') != patternExists.repeat(REPEAT_COUNT)
		|| bufferDeleted.toString('utf8') != patternDeleted.repeat(REPEAT_COUNT)
		|| bufferShredded.toString('utf8') != patternShredded.repeat(REPEAT_COUNT)
	) {
		throw new Error('Something is wrong with fs-atomic-data-store, run tests!');
	}

	let filepath = await record.filepath('partExists');
	let stat = fs.statSync(filepath);
	const blocksize = stat.blksize;

	let m = /(\/dev\/[^\s]+)\s+(\d+)/.exec(child_process.execSync('BLOCKSIZE=' + blocksize + ' df ' + filepath, {encoding: 'utf8'}));	
	const devpath = m[1];
	const blockcount = parseInt(m[2]);

	await record.deletePart('partDeleted');
	await record.shredPart('partShredded');

	devicefd = fs.openSync(devpath, 'r');

	bufferExists = Buffer.from(patternExists);
	bufferDeleted = Buffer.from(patternDeleted);
	bufferShredded = Buffer.from(patternShredded);
	let foundExists = false;
	let foundDeleted = false;
	let foundShredded = false;
	let buf = Buffer.alloc(blocksize);
	for (let i = 1; i <= blockcount; i++) {
		if (i % 50000 == 0) {
			console.log('reading block ' + i + ' of ' + blockcount + ' (' + Math.floor(100 * i / blockcount) + '%)');
		}
		fs.readSync(devicefd, buf, 0, blocksize, null);
		if (!foundExists && buf.indexOf(bufferExists) != -1) {
			foundExists = true;
			console.log('Found existing file');
		}
		if (!foundDeleted && buf.indexOf(bufferDeleted) != -1) {
			foundDeleted = true;
			console.log('Found deleted file');
		}
		if (!foundShredded && buf.indexOf(bufferShredded) != -1) {
			foundDeleted = true;
			console.log('Found shredded file');
		}
		if (foundExists && foundDeleted && foundShredded) {
			console.log('Found everything, stopping early');
			break;
		}
	}

	console.log('Done scanning drive.');
	console.log('Tested device: ' + devpath);
	console.log('Found existing file (want yes): ' + (foundExisting ? 'yes' : 'NO'));
	console.log('Found deleted file (want yes): ' + (foundDeleted ? 'yes' : 'NO'));
	console.log('Found shredded file (want no): ' + (foundExisting ? 'YES' : 'no'));
	if (!foundExisting) {
		console.log('Conclusion: Did not even find existing file. Test failed to function correctly. Either the device is good at hiding files, or this test is garbage.');
		console.log('Result: Inconclusive');
	}
	else if (foundDeleted && !foundShredded) {
		console.log('Conclusion: Found deleted file (as expected), did not find shredded file (good). Shred will help provide secure deletion on this device.');
		console.log('Result: Pass');
	}
	else if (!foundDeleted && !foundShredded) {
		console.log('Conclusion: Did not find shredded file but also didn\'t find deleted file. The device appears to good at handling all deleted files; shred will also help provide greater security against physical recovery.');
		console.log('Result: Pass');
	}
	else if (foundDeleted && foundShredded) {
		console.log('Conclusion: Found shredded file (bad). This device is NOT ok for secure deletion. Shred will not help.');
		console.log('Result: Fail');
	}
	else if (!foundDeleted && foundShredded) {
		console.log('Conclusion: Found shredded file but not deleted file. Test failed to function correctly. This device is probably NOT ok for secure deletion, and shred probably will not help.')
		console.log('Result: Fail');
	}
}

function cleanup() {
	if (devicefd) {
		fs.closeSync(devicefd);
	}
	rimraf.sync(rootDir);
	clearTimeout(timer);
	//console.debug('ran cleanup');
}
run()
	.then(() => {
		console.log('Complete, exiting.');
	})
	.catch((err) => {
		console.error('Caught exception, exiting:', err);
	})
	.finally(() => {
		cleanup();
	})
;
